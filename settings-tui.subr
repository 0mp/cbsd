if [ ! "$_CBSD_SETTINGS_TUI_SUBR" ]; then
_CBSD_SETTINGS_TUI_SUBR=1
###

#required for . ${dialog} 
TMPFILE="${ftmpdir}/inputbox.$$"

jname_msg="Jail name. Name must begin with a letter / a-z /  and not have any special symbols: -,.=%"
host_hostname_msg="Jail Fully Qualified Domain Name"
ip4_addr_msg="Jail IP address from CBSD pool: ${nodeippool}. Use IP/PREFIX form. Comma-separated for aliases. 0 for disable IP creating by CBSD: useful for vnet Jails. Or DHCP for determine free IP automatically"
interface_msg="Auto create and auto remove IP on selected NICs. 0 for disable, auto - for auto detect"
ver_msg="Jail base source version"
zfs_snapsrc_msg="Use this ZFS snapshot as source for jail data, e.g zmirror/jails/jail1@init"
path_msg="Mount point for Jail"
data_msg="Data directory for Jail"
devfs_ruleset_msg="DEVFS ruleset number for Jail devfs"
arch_msg="Target architecture, i386/amd64 or qemu-users arch"
baserw_msg="1,yes - Jail have personal copy of base system with write access, no NULLFS mount. 0,no - read-only and NULLFS"
mount_src_msg="1,yes - Jail have shared /usr/src tree in read-only"
kernelmount_msg="1,yes - Jail have mounted /boot/kernel tree in read-only. Usefull for DTRACE stuff in Jail"
mount_obj_msg="1,yes - Jail have mounted /usr/obj tree in read-only"
mount_ports_msg="1,yes - Jail have /usr/ports /usr/ports tree in read-only"
applytpl_msg="1,yes - Apply CBSD templates for Jail environment"
floatresolv_msg="1,yes - Floating /etc/resolv.conf content"
astart_msg="1,yes - Automatically start Jail when system boot"
vnet_msg="1.yes - Enable VIMAGE/VNet feature"
exec_timeout_msg="The maximum amount of time to wait for a command to complete"
exec_fib_msg="The FIB routing table to set when running commands inside the prison"
exec_consolelog_msg="Jail consolelog file for stdout/stderr output. Possible values: path_to_file, 0 - for disable log to file, 1 - for automatic $logdir/jname.log"
stop_timeout_msg="The maximum amount of time to wait for a jailed processes to exit after sending them a SIGTERM signal"
allow_dying_msg="Allow making changes to a dying Jail"
depend_msg="Specify a Jail or jails that this jail depends on"
allow_zfs_msg="Privileged users inside the jail will be able to mount and unmount the ZFS file system"
protected_msg="Prevent modification or deletion of a environment. 1 - protect/lock"
hidden_msg="Invisible environment flag. 1 - hide environment for frontend"
allow_kmem_msg="Allow kmem and /dev/io devices for jail. Warning: this is insecure options. Use it only for private purposes/X-jails"
allow_mount_msg="Allow privileged users inside the jail mount and unmount file system"
allow_devfs_msg="Allow privileged users inside the jail mount and unmount DEVFS file system"
mount_devfs_msg="Mount DEVFS filesystem in the jail"
mkhostsfile_msg="Automatically set IP/NAME in /etc/hosts when jail started"
allow_nullfs_msg="Allow privileged users inside the jail mount and unmount NULLFS file system"
allow_tmpfs_msg="Allow privileged users inside the jail mount and unmount TMPFS file system"
allow_procfs_msg="Allow privileged users inside the jail mount and unmount PROCFS file system"
allow_fdescfs_msg="Jail may mount the fdescfs file system"
allow_sysvipc_msg="Jail may use SYSV IPC (separated for FreeBSD 11.0+)"
mount_fdescfs_msg="Mount a FDESCFS filesystem on the chrooted /dev/fd directory"
cpuset_msg="Associate group of CPUs to jail. 0 - for all cores, See man 1 cpuset for valid value"
mdsize_msg="Enter size for the images"
jdomain_msg="Specify CBSD node group name for jail"
GET_NODENAME_MSG="Change nodename. Warning: this operation will recreate the ssh keys in $workdir/.ssh dir"
GET_IMGSIZE_MSG="Allocate X size of image free space: 100m, 1g"
GET_SWAPSIZE_MSG="Configure swap partitional in X size (usual RAMx2), 0 - for disable, e.g: 4g"
GET_CPUS_MSG="Number of CPUs: 1, max: 16"
GET_VM_VNC_PORT_MSG="VNC port. 0 - for auto, 1 - disable"
GET_RAM_MSG="RAM size, eg: 512M"
GET_VMPROFILE_MSG="Select profile for VMs"
GET_JAILPROFILE_MSG="Profile for jcreate"
GET_HOSTBRIDGE_MSG="Hostbridge for VMs, eg: hostbridge or amd_hostbridge"
GET_ALLOW_SYSVIPC_MSG="Select SYSVIPC behaviour"
GET_GUESTFS_MSG="Choose FS for boot image"
GET_EFI_MSG="Choose UEFI firmware"
GET_CONSOLE_MSG="Choose default console"
GET_ISOPATH_MSG="Path to ISO image in srcdir/iso, eg: release.iso. 0 - for default img_iso"
GET_VM_ISOPATH_MSG="Select available/registered ISO"

GET_GW4_MSG="Enter default gateway inside VMs or jail"


# show [] * for empty $1 values
# for Option list from -tui
curval()
{
	local T
	[ -z "${1}" ] && return 0

	eval T="\$$1"
	if [ -n "${T}" ]; then
		printf "${T}"
	else
		printf " "
	fi
	return 0
}

# Increment index for menu counter
# required cbsd as shell for is_number
inc_menu_index()
{
	local T
	[ -z "${1}" ] && return 0

	eval T="\$$1"

	if ! is_number ${T}; then
		T=$(( T + 1 ))
	else
		T=$( echo ${T} | /usr/bin/tr '[ABCDEFGHIJKLMNOPQRSTUVWXYZ]' '[BCDEFGHIJKLMNOPQRSTUVWXYZA]' )
	fi
	eval "${1}=${T}"
	return 0
}

# form for $pkglist
get_construct_pkglist()
{
	local _i

	[ -z "${pkglist}" -o "${pkglist}" = "NO" ] && pkglist="${ftmpdir}/tui.$$"

	# load pkg list from profile
	if [ -n "${tpl_pkglist}" ]; then
		if [ -r "${tpl_pkglist}" ]; then
			/bin/cat ${tpl_pkglist} >> ${pkglist}
		else
			for _i in ${tpl_pkglist}; do
				echo ${_i} >> ${pkglist}
			done
		fi
	fi

	pkgbrowser controlmaster="${pkglist}"
	[ ! -s "${pkglist}" ] && pkglist="NO"
}

# form for $srvlist
get_construct_services()
{
	srvlist="${ftmpdir}/srv.$$"
	srvbrowser controlmaster="${srvlist}" baseonly=1
	[ ! -s "${srvlist}" ] && srvlist="NO"
}

# form for $srvlist
get_construct_add_user()
{
	adduser="${ftmpdir}/adduser.$$"
	adduser-tui controlmaster="${adduser}"
	[ ! -s "${adduser}" ] && adduser=
}

# form for $jname
# if $1 = "nosearch" than skip for searching/testing of available jname
get_construct_jname()
{
	local _ok _message _input _retval _oldjname

	_oldjname="${jname}"

	f_dialog_title " jname "

	if [ "$1" = "nosearch" ]; then
			freejname=${jname}
	else
		if [ -n "${jname}" ]; then
			freejname="${jname}"
		else
			freejname=$( freejname default_jailname=${default_jailname} )
		fi
	fi
	_ok=0

	while [ ${_ok} -ne 1 ]; do
		f_dialog_input _input "${jname_msg}" "${freejname}" \
			"${_message}" || return $?

		validate_jname ${_input}
		case $? in
			1)
				jstatus jname="${_input}" >/dev/null 2>&1
				if [ $? -ne 0 ]; then
					_message="ERROR: Jail ${_input} already exist"
				else
					_ok=1
				fi
				;;
			*)
				_message="ERROR: Bad name. Choose other one"
				;;
		esac
	done

	[ -n "${_input}" ] && jname="${_input}"
	# reload some dynamic variables depended from jname
	[ -z "${jname}" ] && return 0
	if [ "${_oldjname}" != "${jname}" ]; then
		#merge_apply_profiles ${etcdir}/defaults/${zero_profile} ${global_profile_file}
		host_hostname="${jname}.${default_domain}"
		path="${jaildir}/${jname}"
		data="${jaildatadir}/${jname}-${jaildatapref}"
		mount_fstab="${jailfstabdir}/${jailfstabpref}${jname}"
		rcconf="${jailrcconfdir}/rc.conf_${jname}"
	fi
}

# form for $host_hostname
get_construct_host_hostname()
{
	local _input _defdomain

	f_dialog_title " host_hostname "

	if [ -n "${host_hostname}" ]; then
		_defdomain="${host_hostname}"
	else
		if [ -n "${default_domain}" ]; then
			if [ -z "${jname}" ]; then
				_defdomain="${jname}.${default_domain}"
			else
				_defdomain="jail1.${default_domain}"
			fi
		else
			_defdomain="my.domain"
		fi
	fi

	f_dialog_input _input "${host_hostname_msg}" "${_defdomain}" \
			"${_message}" || return $?

	[ -n "${_input}" ] && host_hostname="${_input}"
}

get_construct_ip4_addr()
{
	local _ok=0 _input _retval _i _j _existing_ipjail _existing_ip _myip
	local msg_yes msg_no IFS _jname _ips

	f_dialog_title " ip4_addr "

	while [ ${_ok} -ne 1 ]; do
		[ -z "${ip4_addr}" ] && ip4_addr=$( dhcpd 2>/dev/null )
		f_dialog_input _input "${ip4_addr_msg}" "${ip4_addr}" "IP4 or IP6 Address"
		_retval=$?

		[ ${_retval} -ne 0 ] && return 0

		#check ip in two phases:
		# 1) via sqlite database for other's jails ips
		# 2) for ip in LAN

		if [ -z "${_input}" -a "${_input}" = "0" -a "{_input}" = "DHCP" ]; then
			ip4_addr="${_input}"
			return 0
		fi

		msg_yes="Ok"
		msg_no="Not Ok"

		_existing_ipjail=""
		_existing_ip=""
		_myip=""

		IFS=","
		for _i in ${_input}; do
			ipwmask ${_i}
			[ -z "${IWM}" -o "${_i}" = "0" ] && continue
			iptype ${IWM}
			[ $? -ne 0 ] && _myip="${_myip} ${IWM}"
		done

		# check for other jail
		IFS="|"
		_i=0
		eval $( cbsdsql local SELECT jname,ip4_addr FROM jails WHERE ip4_addr!="0" 2>/dev/null |while read _jname _ips; do
			echo jname${_i}=\"$_jname\"
			echo ips${_i}=\"${_ips}\"
			_i=$(( _i + 1 ))
		done )
		unset IFS

		_ok=1

		for _i in $( /usr/bin/seq 0 255 ); do
			eval _jname="\$jname$_i"
			[ -z "${_jname}" ] && break
			# skip for myself
			[ "${_jname}" = "${jname}" ] && continue
			eval _existing_ipjail="\$ips$_i"
			[ -z "${_existing_ipjail}" ] && break

			_existing_ipjail=$( echo ${_existing_ipjail}|/usr/bin/tr "," " " )

			for _i in ${_existing_ipjail}; do
				ipwmask ${_i}
				[ -z "${IWM}" ] && continue
				iptype ${IWM}
				[ $? -eq 1 ] && _existing_ip="${_existing_ip} ${IWM}"
			done

			for _i in ${_existing_ip}; do
				for _j in ${_myip}; do
					[ "${_i}" = "${_j}" ] && _ok=0 && break
				done
				[ ${_ok} -eq 0 ] && break
			done

			if [ ${_ok} -eq 0 ]; then
				f_dialog_noyes "${_i} already assigned to jail: ${_jname}.\nIf you believe that it's ok, choose 'ok' to continue or 'not ok' for another IP address" "WARNING"
				if [ $? -eq 1 ]; then
					_ok=0
					break
				fi
				_ok=2
				break
			fi
		done # check for local jail end

		[ ${_ok} -eq 0 ] && continue # if not ok from previous stage - repeat
		[ ${_ok} -eq 2 ] && _ok=1 && continue

		_ok=1

		local _ipexist=

		# check for ip existance in LAN
		for _i in ${_myip}; do
			IFS=" "
			f_dialog_info "Probing for ${_i} availability. Please wait..."
			unset IFS
			checkip ip=${_i} check=1 2>/dev/null
			if [ $? -eq 2 ]; then
				_ok=0
				_ipexist="${_ipexist} ${_i}"
			fi
		done

		if [ ${_ok} -eq 0 ]; then
			f_dialog_noyes "Seems like ${_ipexist} address already used on several devices on the LAN\nYou can found MAC address by \"arp -an\" command.\n If you believe that it's ok, choose 'ok' to continue or 'not ok' for another IP address" "WARNING"
			[ $? -eq 0 ] && _ok=1
		fi
	done

	ip4_addr="${_input}"
	return 0
}

# form for $interface
# -c choose_default item - defaultitem set to this value
# -s "skip this network list"
# -d 1  - add "disable" choice
# -m 1  - add "manual" choice
# -v 1  - add "vale" device
get_construct_interface()
{
	local _input _def_iface _mynic _mydesc _mystatus
	local defaultitem _skipnics="" _disable=0 _choose
	local _manual=0 _vale=0

	local title=" interface "
	local prompt="${interface_msg}"
	hline=

	local menu_list="
		'EXIT'	'EXIT'	'Exit'
	" # END-QUOTE

	while getopts "c:s:d:m:v:" opt; do
		case "$opt" in
			c) _choose="${OPTARG}" ;;
			s) _skipnics="${OPTARG}" ;;
			d) _disable="${OPTARG}" ;;
			m) _manual="${OPTARG}" ;;
			o) _optional="${OPTARG}" ;;
			v) _vale="${OPTARG}" ;;
		esac
		shift $(($OPTIND - 1))
	done

	menu_list="${menu_list} 'auto'		'auto'		'Recommended: determine nic for jail IP via route table.'"
	if [ "${_manual}" = "1" ]; then
		menu_list="${menu_list} 'manual'	'manual'	'Enter interface by hand.'"
	fi

	if [ ${_disable} -eq 1 ]; then
		menu_list="${menu_list} 'disable'	'disable'	'Do not create/remove IP automatically: IP of jail must be already initialized or for vnet mode'"
	fi
	menu_list="${menu_list} '-'	'-'	''"

	local OLDIFS="${IFS}"
	local IFS=":"

	local _num=1

	eval $( ${miscdir}/nics-list -da -s "${_skipnics}" |while read _nicname _nicdesc _nicstatus; do
		echo "nic${_num}_name=\"${_nicname}\""
		echo "nic${_num}_desc=\"${_nicdesc}\""
		echo "nic${_num}_status=\"${_nicstatus}\""
		_num=$(( _num + 1 ))
		echo "_num=\"${_num}\""
	done )

	if [ "${_vale}" = "1" ]; then
		eval "nic${_num}_name='vale'"
		eval "nic${_num}_desc='very fast Virtual Local Ethernet using the netmap API'"
		eval "nic${_num}_status='UP'"
	fi

	IFS="${OLDIFS}"

	if [ -n "${interface}" ]; then
		case "${interface}" in
			"0")
				defaultitem="disable"
				;;
			*)
				defaultitem="${interface}"
				;;
		esac
	else
		if [ -n "${_choose}" ]; then
			defaultitem="${_choose}"
		elif [ -n "${interface}" ]; then
			defaultitem="${interface}"
		else
			interface="auto"
			defaultitem="auto"
		fi
	fi

	[ -n "${_choose}" ] && defaultitem="${_choose}"

	for _num in $( /usr/bin/seq 1 9999 ); do
		unset _mynic _mydesc _mystatus
		eval _mynic="\$nic${_num}_name"
		[ -z "${_mynic}" ] && break
		eval _mydesc="\$nic${_num}_desc"
		eval _mystatus="\$nic${_num}_status"
		case "${_mynic%%[0-9]*}" in
			tun|bridge|epair|tap|vlan)
				_mydesc="Pseudo interface"
				;;
			lo)
				_mydesc="Loopback interface"
				;;
		esac
		[ -z "${_mydesc}" ] && _mydesc="Not available"
		menu_list="${menu_list} '${_mynic}'	'${_mynic} (${_mystatus} )'	'Description: ${_mydesc}'"
	done

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			case "${mtag}" in
				"-"|"EXIT")
					return 1
					;;
				"disable")
					interface="0"
					;;
				"manual")
					defaultitem="auto"
					title=" interface "
					prompt="Enter interface"
					cbsd_inputbox_simple && interface="${mtag}"
					;;
				*)
					[ -n "${mtag}" ] && interface="${mtag}"
					;;
			esac
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $ver
get_construct_ver()
{
	title=" ver "
	prompt="${ver_msg}"
	defaultitem="${ver}"

	cbsd_inputbox_simple && ver="${mtag}"
}


# form for $zfs_snapsrc
get_construct_zfs_snapsrc()
{
	title=" zfs_snapsrc "
	prompt="${zfs_snapsrc_msg}"
	defaultitem="${zfs_snapsrc}"

	if cbsd_inputbox_simple; then
		if [ -n "${mtag}" ]; then
			zfs_snapsrc="${mtag}"
		else
			unset zfs_snapsrc
		fi
	fi
}


# form for select password
get_password()
{
	local prompt1="Enter New Password"
	local prompt2="Re-enter Password"
	local hline="Use alpha-numeric, punctuation, TAB or ENTER"

	f_dialog_title " Select Password "

	local height1 width1
	f_dialog_inputbox_size height1 width1 \
		"$DIALOG_TITLE"     \
		"$DIALOG_BACKTITLE" \
		"$prompt1"          \
		""                  \
		"$hline"

	local height2 width2
	f_dialog_inputbox_size height2 width2 \
		"$DIALOG_TITLE"     \
		"$DIALOG_BACKTITLE" \
		"$prompt2"          \
		""                  \
		"$hline"

	#
	# Loop until the user provides taint-free/valid input
	#
	local _password1 _password2
	while :; do
		_password1=$( $DIALOG \
			--title "$DIALOG_TITLE"         \
			--backtitle "$DIALOG_BACKTITLE" \
			--hline "$hline"                \
			--ok-label "$msg_ok"            \
			--cancel-label "$msg_cancel"    \
			--insecure                      \
			--passwordbox "$prompt1"        \
			$height1 $width1                \
			2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
		) || return $?
		# Return if user either pressed ESC or chose Cancel/No
		debug= f_dialog_line_sanitize _password1

		_password2=$( $DIALOG \
				--title "$DIALOG_TITLE"         \
				--backtitle "$DIALOG_BACKTITLE" \
				--hline "$hline"                \
				--ok-label "$msg_ok"            \
				--cancel-label "$msg_cancel"    \
				--insecure                      \
				--passwordbox "$prompt2"        \
				$height2 $width2                \
				2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
			) || return $?
		# Return if user either pressed ESC or chose Cancel/No
		debug= f_dialog_line_sanitize _password2

		# Check for NULL entry
		if ! [ "$_password1" -o "$_password2" ]; then
			f_show_msg "Password is empty"
			continue
		fi

		# Check for password mismatch
		if [ "$_password1" != "$_password2" ]; then
			f_show_msg "Password do not match"
			continue
		fi

		mtag="$_password1"
		break
	done

	return $DIALOG_OK
}


# form for $user_pw_root
get_construct_user_pw_root()
{
	if get_password; then
		user_pw_root_crypt=$( ${miscdir}/pwcrypt ${mtag} )
		if [ $? -eq 0 ]; then
			unset user_pw_root
		else
			user_pw_root="${mtag}"
			unset user_pw_root_crypt
		fi
	fi
}

# form for $path
get_construct_path()
{
	title=" path "
	prompt="${path_msg}"
	defaultitem="${path}"

	cbsd_inputbox_simple && path="${mtag}"
}

# form for $data
get_construct_data()
{
	title=" data "
	prompt="${data_msg}"
	defaultitem="${data}"

	cbsd_inputbox_simple && data="${mtag}"
}


# form for $devfs_ruleset
get_construct_devfs_ruleset()
{
	title=" devfs_ruleset "
	prompt="${devfs_ruleset_msg}"
	defaultitem="${devfs_ruleset}"

	cbsd_inputbox_simple && devfs_ruleset="${mtag}"
}

# $1 - 1,0 - default values
get_construct_yesno()
{
	local _default=1
	msg_yes="no"
	msg_no="yes"

	[ -n "${1}" ] && _default="${1}"

	if [ ${_default} -eq 0 ]; then
		f_dialog_yesno "${msg}" "${hline}"
	else
		f_dialog_noyes "${msg}" "${hline}"
	fi

	return $?
}

get_construct_mdsize()
{
	title=" mdsize "
	prompt="${mdsize_msg}"
	defaultitem="${mdsize}"

	cbsd_inputbox_simple && mdsize="${mtag}"
}

get_construct_imgsize()
{
	local _input

	f_dialog_title " imgsize "

	f_dialog_input _input "${GET_IMGSIZE_MSG}:" "${imgsize}" \
			"${_message}" || return $?

	imgsize="${_input}"
}

get_construct_swapsize()
{
	local _input

	f_dialog_title " swapsize "

	f_dialog_input _input "${GET_SWAPSIZE_MSG}:" "${swapsize}" \
			"${_message}" || return $?

	swapsize="${_input}"
}


# form for $exec_timeout
get_construct_exec_timeout()
{
	local _input

	f_dialog_title " exec_timeout "

	f_dialog_input _input "${exec_timeout_msg}" "${exec_timeout}" \
			"${_message}" || return $?

	exec_timeout="${_input}"
}

# form for $exec_fib
get_construct_exec_fib()
{
	local _input

	f_dialog_title " exec_fib "

	f_dialog_input _input "${exec_fib_msg}" "${exec_fib}" \
			"${_message}" || return $?

	exec_fib="${_input}"
}

# form for $exec_consolelog
get_construct_exec_consolelog()
{
	local _input

	f_dialog_title " exec_consolelog "

	f_dialog_input _input "${exec_consolelog_msg}" "${exec_consolelog}" \
		"${_message}" || return $?

	exec_consolelog="${_input}"
}

# form for $stop_timeout
get_construct_stop_timeout()
{
	local _input

	f_dialog_title " stop_timeout "

	f_dialog_input _input "${stop_timeout_msg}" "${stop_timeout}" \
		"${_message}" || return $?

	stop_timeout="${_input}"
}

# form for $depend
get_jail_depend()
{
	local _input

	f_dialog_title " depend "

	f_dialog_input _input "${depend_msg}" \
		"${_message}" || return $?

	depend="${_input}"
}

# form for $cpuset
get_construct_cpuset()
{
	local _input

	f_dialog_title " cpuset "

	f_dialog_input _input "${cpuset_msg}" "${cpuset}" \
			"${_message}" || return $?

	cpuset="${_input}"
}

# form for $cpus
get_construct_vm_cpus()
{
	local _input

	f_dialog_title " cpu "

	f_dialog_input _input "${GET_CPUS_MSG}" "${vm_cpus}" \
			"${_message}" || return $?

	vm_cpus="${_input}"
}


# form for $vm_vnc_port
get_construct_vm_vnc_port()
{
	local _input

	f_dialog_title " vnc port "

	f_dialog_input _input "${GET_VM_VNC_PORT_MSG}" "${vm_vnc_port}" \
			"${_message}" || return $?

	vm_vnc_port="${_input}"
}

# form for $ram
get_construct_vm_ram()
{
	local _input

	f_dialog_title " ram "

	f_dialog_input _input "${GET_RAM_MSG}" "${vm_ram}" \
			"${_message}" || return $?
	
	vm_ram="${_input}"
}

# form for $vm_iso_path
get_construct_isopath()
{
	local _input

	f_dialog_title " isopath "

	f_dialog_input _input "${GET_ISOPATH_MSG}" "${vm_iso_path}" \
			"${_message}" || return $?

	vm_iso_path="${_input}"
}

# form for $arch
get_construct_arch()
{
	local _input _res

	local qemu_mips64=$( /usr/bin/which qemu-mips64-static 2>/dev/null )
	local qemu_arm=$( /usr/bin/which qemu-arm-static 2>/dev/null )

	local amd64_menu=
	local i386_menu=
	local amd64_desc=
	local i386_desc=

	local arm_menu=
	local mips_menu=
	local arm_desc=
	local mips_desc=

	local qemu_mips64_desc=
	local qemu_arm_desc=
	local qemu_mips64_enable=
	local qemu_arm_enable=
	local qemu_mips64_menu="MIPS64"
	local qemu_arm_menu="ARMv6"

	# test for qemu_mips64
	if [ -n "${qemu_mips64}" ]; then
		_res=$( 2>&1 /usr/bin/ldd ${qemu_mips64} |${GREP_CMD} -q "not a dynamic ELF executable" )
		if [ $? -eq 0 ]; then
			qemu_mips64_enable=1
			qemu_mips64_desc="MIPS64 via ${qemu_mips64}"
		else
			qemu_mips64_enable=0
			qemu_mips64_desc="${qemu_mips64} is not static. Please rebuild with STATIC ( emulators/qemu-user-static )"
		fi
	else
		qemu_mips64_enable=0
		qemu_mips64_desc="You have no qemu-user: please install qemu-devel with BSD_USER and STATIC ops ( emulators/qemu-user-static )"
	fi

	# test for qemu_arm
	if [ -n "${qemu_arm}" ]; then
		_res=$( 2>&1 /usr/bin/ldd ${qemu_arm} |${GREP_CMD} -q "not a dynamic ELF executable" )
		if [ $? -eq 0 ]; then
			qemu_arm_enable=1
			qemu_arm_desc="ARM via ${qemu_arm}"
		else
			qemu_arm_enable=0
			qemu_arm_desc="${qemu_arm} is not static. Please rebuild with STATIC ( emulators/qemu-user-static )"
		fi
	else
		qemu_arm_enable=0
		qemu_arm_desc="You have no qemu-user: please install qemu-devel with BSD_USER and STATIC ops ( emulators/qemu-user-static )"
	fi

	local defaultitem="${arch}"

	case "${hostarch}" in
		"amd64")
			amd64_menu="*"
			amd64_desc="This is native architecture for this node"
			;;
		"i386")
			i386_menu="*"
			i386_desc="This is native architecture for this node"
			;;
		"arm")
			arm_menu="*"
			arm_desc="This is native architecture for this node"
			;;
		"mips")
			mips_menu="*"
			mips_desc="This is native architecture for this node"
			;;
	esac

	case "${arch}" in
		amd64)
			local menu_list="
			'amd64'	'x86-64 ${amd64_menu}'		'64 bit architecture. ${amd64_desc}'
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
		i386)
			local menu_list="
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
		arm)
			local menu_list="
			'arm'	'arm ${arm_menu}'		'ARM architecture. ${arm_desc}'
			" # END-QUOTE
			;;
		mips)
			local menu_list="
			'mips'	'mips ${mips_menu}'		'MIPS architecture. ${mips_desc}'
			" # END-QUOTE
			;;
		*)
			local menu_list="
			'amd64'	'x86-64 ${amd64_menu}'		'64 bit architecture. ${amd64_desc}'
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
	esac

	if [ ${qemu_arm_enable} -eq 1 ]; then
		menu_list="${menu_list} 'arm'	'${qemu_arm_menu}'	'${qemu_arm_desc}'"
	else
		menu_list="${menu_list} ''	'armv6 unsupported'	'${qemu_arm_desc}'"
	fi

	if [ ${qemu_mips64_enable} -eq 1 ]; then
		menu_list="${menu_list} 'mips'	'${qemu_mips64_menu}'	'${qemu_mips64_desc}'"
	else
		menu_list="${menu_list} ''	'mips unsupported'	'${qemu_mips64_desc}'"
	fi

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			if [ -n "${mtag}" ]; then
				arch="${mtag}"
			else
				arch="${hostarch}"
			fi
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_hostbridge
get_construct_vm_hostbridge()
{
	local _input _res

	local title="${GET_HOSTBRIDGE_MSG}"
	local defaultitem="${vm_hostbridge}"

	local menu_list="
		'hostbridge'		'hostbridge'		'Provide a simple host bridge.'
		'amd_hostbridge'	'amd_hostbridge'	'The amd_hostbridge emulation is identical but uses a PCI vendor ID of AMD'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_hostbridge="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vnc_resolution
get_construct_bhyve_vnc_resulution_menu()
{
	local _input _res

	# for default values
	readconf vnc.conf

	local title="VNC Resolution"
	local defaultitem="${bhyve_vnc_resolution}"

	local menu_list="
		'640x480'		'640 x 480'		'640 x 480'
		'800x600'		'800 x 600'		'800 x 600'
		'1024x768'		'1024 x 768'		'1024 x 768'
		'1280x720'		'1280 x 720'		'1280 x 720'
		'1280x1024'		'1280 x 1024'		'1280 x 1024'
		'1600x900'		'1600 x 900'		'1600 x 900'
		'1600x1200'		'1600 x 1200'		'1600 x 1200'
		'1920x1080'		'1920 x 1080'		'1920 x 1080'
		'1920x1200'		'1920 x 1200'		'1920 x 1200'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && bhyve_vnc_resolution="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $allow_sysvipc
get_construct_allow_sysvipc()
{
	local _input _res

	local title="${GET_ALLOW_SYSVIPC_MSG}"
	local defaultitem="${allow_sysvipc}"

	local menu_list="
		'new'			'new'			'New SYSV IPC: separated isolated segments for jail (FreeBSD 11+)'
		'inherit'		'inherit'		'Inherit (shared) SYSV IPC from parent environment'
		'disable'		'disable'		'Disable SYSV IPC within jail'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && allow_sysvipc="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# Submenu for bhyve options
get_construct_bhyve_options_menu()
{
	local _input _res item_let=A

	local title="Additional bhyve arguments"
	local defaultitem=
	local menu_choice=
	local _checkbox="bhyve_generate_acpi bhyve_wire_memory bhyve_rts_keeps_utc bhyve_force_msi_irq bhyve_x2apic_mode bhyve_mptable_gen bhyve_ignore_msr_acc"

	f_dialog_default_fetch defaultitem

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} bhyve_generate_acpi'		'[${bhyve_generate_acpi_mark}]'		'Generate ACPI tables.  Required for FreeBSD/amd64 guests'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_wire_memory'			'[${bhyve_wire_memory_mark}]'		'Wire guest memory'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_rts_keeps_utc'		'[${bhyve_rts_keeps_utc_mark}]'		'RTC keeps UTC time'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_force_msi_irq'		'[${bhyve_force_msi_irq_mark}]'		'Force virtio PCI device to use MSI interrupts instead of MSI-X'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_x2apic_mode'			'[${bhyve_x2apic_mode_mark}]'		'The guests local APIC is configured in x2APIC mode'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_mptable_gen'			'[${bhyve_mptable_gen_mark}]'		'Disable MPtable generation'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_ignore_msr_acc'		'[${bhyve_ignore_msr_acc_mark}]'	'Ignore accesses to unimplemented MSRs'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}


# Submenu for vnc options
get_construct_vnc_options_menu()
{
	local _input _res item_let=A

	local title="VNC Options"
	local defaultitem=
	local menu_choice=
	local _checkbox="cd_vnc_wait"

	f_dialog_default_fetch defaultitem

	readconf vnc.conf
	[ -z "${bhyve_vnc_resolution}" ] && bhyve_vnc_resolution="${default_vnc_width}x${default_vnc_height}"
	[ -z "${bhyve_vnc_tcp_bind}" ] && bhyve_vnc_tcp_bind="${default_vnc_tcp_bind}"

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} cd_vnc_wait'		'[${cd_vnc_wait_mark}]'		'When booting from CD - wait connections on VNC before VM run'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_vnc_resolution'	'[${bhyve_vnc_resolution}]'		'Default: width - ${default_vnc_width}, height - ${default_vnc_height}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_vnc_tcp_bind'	'[${bhyve_vnc_tcp_bind}]'		'Default: ${default_vnc_tcp_bind}'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}



# Submenu for bhyve options
get_construct_bhyve_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_bhyve_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"

}


# Submenu for bhyve options
get_construct_vnc_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_vnc_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		bhyve_vnc_tcp_bind)
			title=" vnc bind "
			prompt="default via vnc.conf: ${default_vnc_tcp_bind}\nUse 0.0.0.0 for all IPs"
			defaultitem="${bhyve_vnc_tcp_bind}"
			cbsd_inputbox_simple && bhyve_vnc_tcp_bind="${mtag}"
			;;
		bhyve_vnc_resolution)
			get_construct_bhyve_vnc_resulution_menu
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"

}


# form for $vm_guestfs
get_construct_vm_guestfs()
{
	local _input _res

	local title="${GET_GUESTFS_MSG}"
	local defaultitem="${vm_guestfs}"

	local menu_list="
		'zfs'	'zfs'	'ZFS filesystem'
		'ufs'	'ufs'	'UFS filesystem'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_guestfs="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_boot
get_construct_vm_boot()
{
	local _res

	local vm_boot_data="${ftmpdir}/vm_boot.$$"

	bootmgmt selected=${vm_boot} controlmaster=${vm_boot_data}

	retval=$?

	case $retval in
		${DIALOG_OK})
			. ${vm_boot_data}
			;;
		*)
			;;
	esac

	/bin/rm -f ${vm_boot_data}

	return ${retval}
}

# form for $vm_efi
get_construct_vm_efi()
{
	local _input _res

	local title="${GET_EFI_MSG}"
	local defaultitem="${vm_efi}"

	local menu_list="
		'none'		'No UEFI boot'	'Legacy boot mode'
		'uefi'		'UEFI'		'Boot using UEFI firmware'
		'uefi_csm'	'UEFI CSM'	'Boot using UEFI CSM firmware'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_efi="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $vm_console
get_construct_vm_console()
{
	local _input _res

	local title="${GET_CONSOLE_MSG}"
	local defaultitem="${vm_console}"

	local menu_list="
		'tmux'		'tmux console'			'No serial, just tmux session'
		'nmdm'		'serial console via nmdm'	'Serial console via nullmodem driver'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_console="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $arch
get_construct_vm_os_type()
{
	local _input
	local defaultitem="${vm_os_type}"

	unset menu_list

	# load menu_list from external source by emulator opportunity
	if [ -f "${sharedir}/emulators/ostype_${emulator}.subr" ]; then
		. ${sharedir}/emulators/ostype_${emulator}.subr
	else
		f_dialog_msgbox "No such menu_list for emulator ${emulator}:\n${sharedir}/emulators/ostype_${emulator}.subr"
		return 0
	fi

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_os_type="${mtag}"
			unset vm_os_profile jname imgsize
			;;
		*)
			;;
	esac

	return ${retval}
}


get_construct_vm_iso_path()
{
	local menu_list=
	local vm_res
	local i

	local title=" Select ISO "
	local prompt="${GET_VM_ISOPATH_MSG}"

	vm_res=$( cbsdsql storage_media SELECT name FROM media WHERE type=\"iso\" )

	[ -z "${vm_res}" ] && return 0

	for i in ${vm_res}; do
		menu_list="${menu_list} '${i}' '${i}' '${i}'"
	done

	defaultitem="${vm_iso_path}"

	mtag=
	cbsd_menubox

	case $retval in
		${DIALOG_OK})
			if [ -n "${mtag}" ]; then
				register_iso_as="${mtag}"
				vm_iso_path="${mtag}"
				alt_iso="${mtag}"
			fi
			;;
		*)
			;;
	esac

	return ${retval}


}


# form for $vm_os_profile
# if $1 not empty just load profile without dialogizing
get_construct_vm_os_profile()
{
	local _input _search_profile="vm-${vm_os_type}" _res vm_profile _myprofiles="" _myfile _all _num _myfile
	local menu_list=

	local title=" profile "
	local prompt="${GET_VMPROFILE_MSG}"

	_res=$( /usr/bin/find ${etcdir}/defaults ${etcdir} -type f -depth 1 -maxdepth 1 -name ${_search_profile}\* -exec /bin/realpath {} \;| /usr/bin/sort -u )

	_all=0

	for i in ${_res}; do
		unset vm_profile
		eval $( ${GREP_CMD} ^vm_profile= ${i} )
		eval $( ${GREP_CMD} ^active= ${i} )

		[ -z "${vm_profile}" -o ${active} -eq 0 ] && continue

		unset long_description
		eval $( ${GREP_CMD} ^long_description= ${i} )

		[ -z "${long_description}" ] && long_description="${vm_profile}"

		_mypath=$( echo $i | /usr/bin/sed s:^${workdir}/::g )
		menu_list="${menu_list} '${vm_profile}' '${_mypath}' '${long_description}'"
		# store filename
		local profile${_all}="${vm_profile}"
		local file${_all}="${i}"
		_all=$(( _all + 1 ))
	done

	[ -z "${menu_list}" ] && unset vm_os_profile && return 0

	defaultitem="${vm_os_profile}"

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			pkgnum=0
			unset pkglist tpl_pkglist from_jail vm_profile profile
			alt_iso=
			vm_os_profile="${mtag}"
			_num=0
			_myfile=$( while [ ${_num} -ne ${_all} ]; do
				eval _myfile="\$file${_num}"
				eval _prof="\$profile${_num}"
				[ "${vm_os_profile}" = "${_prof}" ] && echo "${_myfile}" && exit
				_num=$(( _num + 1 ))
			done )

			[ -z "${_myfile}" ] && return 0

			if [ -f "${_myfile}" ]; then
				. ${_myfile}
				global_profile_file="${_myfile}"
			fi
			;;
		*)
			;;
	esac

	vm_iso_path="${register_iso_as}"

	return ${retval}
}

# form for $profile
# if $1 not empty, just load $1 profile without dialogizing
get_construct_profile()
{
	local _input _retval _search_profile="${emulator}-freebsd-" jail_profile _res _myprofiles="" _myfile
	local _old_profile="${profile}"
	local menu_list=

	local defaultitem="${profile}"
	local title=" profile "
	local prompt="${GET_JAILPROFILE_MSG}"

	# default must be first due to last dir with user settings must overwrite
	_res=$( /usr/bin/find ${etcdir}/defaults ${etcdir} -type f -depth 1 -maxdepth 1 -name ${_search_profile}\* -exec /bin/realpath {} \;| /usr/bin/sort -u | /usr/bin/sort -n )

	for i in ${_res}; do
		unset jail_profile
		eval $( ${GREP_CMD} ^jail_profile= ${i} )
		eval $( ${GREP_CMD} ^long_description= ${i} )
		_mypath=$( echo ${i} | /usr/bin/sed s:^${workdir}/::g )
		menu_list="${menu_list} '${jail_profile}' '${_mypath}' '${long_description}'"
		#store filename
		local file_${jail_profile}="${i}"
	done

	[ -z "${menu_list}" ] && unset jail_profile && return 0

	# unset for previous template package list
	unset tpl_pkglist

	if [ -z "${1}" ]; then
		cbsd_menubox
		case $retval in
			${DIALOG_OK})
				pkgnum=0
				unset pkglist tpl_pkglist from_jail vm_profile profile
				if [ -n "${mtag}" ]; then
					profile="${mtag}"
				else
					profile="${_old_profile}"
				fi
				;;
			*)
				;;
		esac
	else
		profile="${1}"
	fi

	eval _myfile="\$file_$profile"

	if [ -f "${_myfile}" ]; then
		. ${_myfile}
		global_profile_file="${_myfile}"
		# reload some dynamic variables depended from jname
		if [ -f ${etcdir}/${zero_profile} ]; then
			merge_apply_profiles ${global_profile_file} ${etcdir}/${zero_profile}
			merge_apply_profiles ${etcdir}/${zero_profile} ${_myfile}
		else
			merge_apply_profiles ${global_profile_file} ${etcdir}/defaults/${zero_profile}
			merge_apply_profiles ${etcdir}/defaults/${zero_profile} ${_myfile}
		fi
	fi

	# populate pkglist from tpl_pkglist if not empty
	if [ -n "${tpl_pkglist}" ]; then
		if [ -r "${tpl_pkglist}" ]; then
			# its file
			pkglist="${tpl_pkglist}"
		else
			pkglist="${ftmpdir}/tui.$$"
			trap "/bin/rm -f ${pkglist}" HUP INT ABRT BUS TERM EXIT
			for _i in ${tpl_pkglist}; do
				echo ${_i} >> ${pkglist}
			done
		fi
	fi

	return ${retval}
}


# form for $gw4
get_construct_gw4()
{
	local _input

	f_dialog_title " gw4 "

	f_dialog_input _input "${GET_GW4_MSG}" "${gw4}" \
			"${_message}" || return $?
	
	gw4="${_input}"
}


# form for $nodename
get_construct_nodename()
{
	title=" nodename "
	prompt="${nodename_msg}"
	defaultitem="${nodename}"

	cbsd_inputbox_simple && nodename="${mtag}"
}

# form for $jdomain
get_construct_jdomain()
{
	title=" jdomain "
	prompt="${jdomain_msg}"
	defaultitem="${jdomain}"

	cbsd_inputbox_simple && jdomain="${mtag}"
}


make_bhyve_part()
{
/bin/cat >> ${TMPFILE} << EOF
exec_start="${exec_start}"
exec_stop="${exec_stop}"
emulator="bhyve";
imgsize="${imgsize}";
vm_cpus="${vm_cpus}";
vm_ram="${vm_ram}";
vm_os_type="${vm_os_type}";
vm_efi="${vm_efi}";

iso_site="${iso_site}";
iso_img="${iso_img}";
register_iso_name="${register_iso_name}"
register_iso_as="${register_iso_as}"

vm_hostbridge="${vm_hostbridge}";
bhyve_flags="${bhyve_flags}";
virtio_type="${virtio_type}";
gw4="${gw4}";
vm_os_profile="${vm_os_profile}";
jprofile="${jprofile}";
swapsize="${swapsize}";
vm_iso_path="${register_iso_as}";
vm_guestfs="${vm_guestfs}";
vm_vnc_port="${vm_vnc_port}";

bhyve_generate_acpi="${bhyve_generate_acpi}";
bhyve_wire_memory="${bhyve_wire_memory}";
bhyve_rts_keeps_utc="${bhyve_rts_keeps_utc}";
bhyve_force_msi_irq="${bhyve_force_msi_irq}";
bhyve_x2apic_mode="${bhyve_x2apic_mode}";
bhyve_mptable_gen="${bhyve_mptable_gen}";
bhyve_ignore_msr_acc="${bhyve_ignore_msr_acc}";

cd_vnc_wait="${cd_vnc_wait}";
bhyve_vnc_resolution="${bhyve_vnc_resolution}";
bhyve_vnc_tcp_bind="${bhyve_vnc_tcp_bind}";

with_img_helpers="";
runasap="${runasap}";
EOF
}


make_virtualbox_part()
{
/bin/cat >> ${TMPFILE} << EOF
exec_start="${exec_start}"
exec_stop="${exec_stop}"
emulator="${emulator}";
imgsize="${imgsize}";
vm_cpus="${vm_cpus}";
vm_ram="${vm_ram}";
vm_os_type="${vm_os_type}";
vm_efi="${vm_efi}";

iso_site="${iso_site}";
iso_img="${iso_img}";
register_iso_name="${register_iso_name}"
register_iso_as="${register_iso_as}"

vm_hostbridge="${vm_hostbridge}";
bhyve_flags="${bhyve_flags}";
virtio_type="${virtio_type}";
gw4="${gw4}";
vm_os_profile="${vm_os_profile}";
jprofile="${jprofile}";
swapsize="${swapsize}";
vm_guestfs="${vm_guestfs}";
vm_vnc_port="${vm_vnc_port}";
with_img_helpers="";
runasap="${runasap}";
EOF
}

make_xen_part()
{
	make_virtualbox_part
}


make_emulator_part()
{
/bin/cat >> ${TMPFILE} << EOF
exec_start="/bin/${emulator} ${exec_start}";
exec_stop="/bin/${emulator} ${exec_stop}";
EOF

}


# generate temp .jconf
gen_jconf()
{
	local TMPFILE="${ftmpdir}/${jname}.$$.jconf"
	local fstab="${jailfstabdir}/${jailfstabpref}${jname}"
	local rcconf="${jailrcconfdir}/rc.conf_${jname}"

	# original jail area
	/bin/cat > ${TMPFILE} << EOF
# DO NOT EDIT THIS FILE. PLEASE USE INSTEAD:
# cbsd jconfig jname=${jname}
relative_path="1";
jname="${jname}";
path="${path}";
host_hostname="${host_hostname}";
ip4_addr="${ip4_addr}";
mount_devfs="${mount_devfs}";
allow_mount="${allow_mount}";
allow_devfs="${allow_devfs}";
allow_nullfs="${allow_nullfs}";
mount_fstab="${fstab}";
arch="${arch}";
mkhostsfile="${mkhostsfile}";
devfs_ruleset="${devfs_ruleset}";
ver="${ver}";
basename="${basename}";
baserw="${baserw}";
mount_src="${mount_src}";
mount_obj="${mount_obj}";
mount_kernel="${mount_kernel}";
mount_ports="${mount_ports}";
astart="${astart}";
data="${data}";
vnet="${vnet}";
applytpl="${applytpl}";
mdsize="${mdsize}";
rcconf="${jailrcconfdir}/rc.conf_${jname}";
floatresolv="${floatresolv}";
zfs_snapsrc="${zfs_snapsrc}";

exec_poststart="${exec_poststart}";
exec_poststop="${exec_portstop}";
exec_prestart="${exec_prestart}";
exec_prestop="${exec_prestop}";

exec_master_poststart="${exec_master_poststart}";
exec_master_poststop="${exec_master_poststop}";
exec_master_prestart="${exec_master_prestart}";
exec_master_prestop="${exec_master_prestop}";
pkg_bootstrap="${pkg_bootstrap}";
with_img_helpers="";
runasap="${runasap}";
EOF

	[ -n "${interface}" ] && /bin/cat >> ${TMPFILE} <<EOF
interface="${interface}";
EOF


	[ -n "${jailskeldir}" ] && /bin/cat >> ${TMPFILE} <<EOF
jailskeldir="${jailskeldir}";
EOF

	[ -n "${customskel}" ] && /bin/cat >> ${TMPFILE} <<EOF
customskel="${customskel}";
EOF

	[ -n "${jailsysskeldir}" ] && /bin/cat >> ${TMPFILE} <<EOF
jailsysskeldir="${jailsysskeldir}";
EOF

	if [ -z "${profile}" ]; then
/bin/cat >> ${TMPFILE} <<EOF
jail_profile="default";
EOF
		else
/bin/cat >> ${TMPFILE} <<EOF
jail_profile="${profile}";
EOF
	fi

	# additional area
	[ -n "${user_pw_root_crypt}" ] && /bin/cat >> ${TMPFILE} <<EOF
# root password
user_pw_root_crypt='${user_pw_root_crypt}';
EOF

	[ -n "${user_pw_root}" ] && /bin/cat >> ${TMPFILE} <<EOF
# root password
user_pw_root='${user_pw_root}';
EOF

	[ -n "${pkglist}" ] && echo "pkglist=\"${pkglist}\";" >> ${TMPFILE}

	if [ -n "${srvlist}" -a -r "${srvlist}" ]; then
		/bin/cat ${srvlist} >> ${TMPFILE}
		/bin/rm -f ${srvlist}
	fi

	if [ -n "${adduser}" -a -r "${adduser}" ]; then
		/bin/cat ${adduser} >> ${TMPFILE}
		/bin/rm -f ${adduser}
	fi
	# end of additional area

	${SYSRC_CMD} -qf ${TMPFILE} exec_start="${exec_start}" > /dev/null 2>&1
	${SYSRC_CMD} -qf ${TMPFILE} exec_stop="${exec_stop}" > /dev/null 2>&1

	if [ -n "${alt_iso}" ]; then
		iso_site=
		iso_img=
		register_iso_name=
		register_iso_as="${alt_iso}";		# vm_os_path
	fi

	case "${emulator}" in
		"bhyve")
			make_bhyve_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd bcreate jconf=${TMPFILE}${NORMAL}"
			bcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
		;;
		"virtualbox")
			make_virtualbox_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd vcreate jconf=${TMPFILE}${NORMAL}"
			vcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
		;;
		"xen")
			make_xen_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd xcreate jconf=${TMPFILE}${NORMAL}"
			xcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
		;;
		"jail")
			echo "emulator=\"${emulator}\"" >> ${TMPFILE}
			getyesno "Do you want to create jail immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd jcreate jconf=${TMPFILE}${NORMAL}"
			jcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
		;;
		*)
			err 1 "${MAGENTA}Unsupported emulator type: ${GREEN}${emulator}${NORMAL}"
		;;
	esac

	return 0
}


merge_apply_profiles()
{
	local _out
	[ -z "${1}" ] && return 0

	local _orig="$1"; shift
	local _custom="$1"; shift
	local _i

	[ ! -f "${_orig}" ] && return 0
	if [ ! -f "${_custom}" ]; then
		. ${_orig}
		return 0
	fi

	_out=$( /usr/bin/mktemp )

	merge from=${_orig} to=${_custom} out=${_out}

	. ${_out}
	/bin/rm -f ${_out}

}

# invert boolean value for \$$1
# example: invert_checkbox $astart
invert_checkbox()
{
	[ -z "${1}" ] && return 1

	eval _mytest=\$$1
	if [ "${_mytest}" = "1" ]; then
		export ${1}=0
	else
		export ${1}=1
	fi
	continue
}

###
fi
