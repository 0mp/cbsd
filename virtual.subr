if [ ! "$_CBSD_VIRTUAL_SUBR" ]; then
_CBSD_VIRTUAL_SUBR=1
###


# generic/shared func for custom virtuals

init_iso()
{
	if [ -z "${iso_img}" ]; then
		${ECHO} "no cd: iso_img and register_iso_as is empty"
		return 1
	fi

	# test for media database
	local media_db

	if [ -n "${vm_iso_path}" ]; then
		${ECHO} "${MAGENTA}vm_iso_path: ${GREEN}${vm_iso_path}"

		media_db=$( media mode=get name=${vm_iso_path} path="" )
		if [ -n "${media_db}" -a -r "${media_db}" ]; then
			${ECHO} "${MAGENTA}media found: ${GREEN}${vm_iso_path}${MAGENTA} --> ${GREEN}${media_db}${NORMAL}"
			iso_img="${media_db}"
			return 0
		fi
	fi

	local _mydir="${srcdir}/iso"
	local _myfile="${_mydir}/${iso_img}"
	local i

	[ ! -d "${_mydir}" -o ! -h "${_mydir}" ] && /bin/mkdir -p ${_mydir}

	[ -z "${iso_img_dist}" ] && iso_img_dist="${iso_img}"

	# Unessesary when we boot not from cd
	[ "${vm_boot}" != "cd" ] && iso_img="${_myfile}" && return 0

	if [ -z "${register_iso_name}" ]; then
		_myfile="${_mydir}/${iso_img}"
		${ECHO} "${MAGENTA}Warning: empty register_iso_name. Use iso_img: ${_myfile}"
	fi

	_myfile=$( media mode=get name="${register_iso_name}" path='' )
	[ -z "${_myfile}" ] && _myfile="${_mydir}/${register_iso_name}"

	if [ -r "${_myfile}" ]; then
		iso_img="${_myfile}"
		return 0
	fi

	if [ ! -f "${_myfile}" -a "${fetch}" = "1" ]; then
		[ -z "${iso_site}" ] && ${ECHO} "${MAGENTA}No such iso: ${GREEN}${_myfile}${MAGENTA} and ${GREEN}iso_site${MAGENTA} variable not found" && return 1
		${ECHO} "${MAGENTA}No such media: ${GREEN}${_myfile}${MAGENTA} in ${GREEN}${_mydir}${NORMAL}"
		ALWAYS_YES=1
		if getyesno "Shall i download it from: ${iso_site}?"; then
			${ECHO} "${MAGENTA}Download to: ${GREEN}${_myfile}${NORMAL}"

			if [ -n "${iso_extract}" ]; then
				outfile="${_mydir}/${iso_img_dist}"
			else
				outfile="${_myfile}"
			fi

			for i in ${iso_site}; do
				${ECHO} "${MAGENTA}Processing: ${GREEN}${i}${NORMAL}"
				[ -s "${_myfile}" ] && continue # skip all other mirror when file exist
				fetchme -o ${outfile} -u ${i}${iso_img_dist}
				[ -r ${outfile} ] && break
			done

		fi
		ALWAYS_YES=0
	fi

	if [ -n "${iso_extract}" -a -f "${outfile}" ]; then
		${ECHO} "${MAGENTA}Extracting...${NORMAL}"
		set -o xtrace
		cd ${_mydir}
		${iso_extract} ${outfile}
		set +o xtrace
		[ -f "${outfile}" ] && /bin/rm -f ${outfile}
		[ -f "${_mydir}/${iso_img}" ] && /bin/mv ${_mydir}/${iso_img} ${_myfile}
	fi

	if [ ! -s "${_myfile}" ]; then
		${ECHO} "${MAGENTA}No such ISO image. Try to download it manually and put into ${GREEN}${_myfile}${NORMAL}"
		err 1 "${MAGENTA}Or register (via cbsd media mode=register) it with vm_iso_path name: ${GREEN}${vm_iso_path}${NORMAL}"
	fi

	if [ -r "${_myfile}" ]; then
		${ECHO} "${MAGENTA}Automatically register iso as: ${GREEN}${register_iso_name}${NORMAL}"
		local reg_name
		if [ -n "${register_iso_as}" ]; then
			reg_name="${register_iso_as}"
		else
			reg_name="${register_iso_name}"
		fi
		media mode=register name="${reg_name}" path="${_myfile}"
	fi

	iso_img="${_myfile}"
	return 0
}

check_for_empty_hdd()
{
	local _err
	local dsk_size=0
	[ "${vm_boot}" != "hdd" ] && return 0
	# check for empty disk
	local checkres

	if [ -h "${data}/${MDFILE}" ]; then
		. $zfstool
		if is_getzvol ${data}/${MDFILE}; then
			dsk_size=$( /sbin/zfs get -Hp -o value refer ${is_zvol} 2>/dev/null )
		else
			checkres=$( /usr/bin/readlink ${data}/${MDFILE} )
			[ -r ${checkres} ] && dsk_size=$( /usr/bin/du -sk ${checkres} 2>/dev/null |/usr/bin/awk '{printf $1}' )
		fi
	else
		checkres="${data}/${MDFILE}"
		[ -r ${checkres} ] && dsk_size=$( /usr/bin/du -sk ${checkres} 2>/dev/null |/usr/bin/awk '{printf $1}' )
	fi

	if is_number ${dsk_size}; then
		err 1 "${MAGENTA}Unable to determine disk size for ${data}/${MDFILE}, result: [${dsk_size}]${NORMAL}"
	fi


	if [ ${dsk_size} -lt 327680 ]; then
		${ECHO} "${MAGENTA}Looks like ${GREEN}${data}/${MDFILE}${MAGENTA} is empty.${NORMAL}"
		ALWAYS_YES=1
		if getyesno "May be you want to boot from CD? "; then
			${ECHO} "${MAGENTA}Temporary boot device: ${GREEN}cd${NORMAL}"
			cd_boot_once=1
			vm_boot="cd";
		fi
		ALWAYS_YES=0
	fi
}


# print next free vnc/rdp port
# $1 - start port
get_next_rd_port()
{
	local _start=5900

	[ -n "${1}" ] && _start="$1"

	for _rd_port in $( /usr/bin/seq ${_start} 6000 ); do
		/usr/bin/nc -w 2 -z 127.0.0.1 ${_rd_port} > /dev/null 2>&1 || break
	done
	echo ${_rd_port}
}

###
fi
